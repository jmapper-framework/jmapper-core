#sidebar TableOfContents

= Overview of JMapper Framework =

Currently, there are many frameworks that can significantly reduce the workload, leading mainly two major benefits: *robustness* and *productivity*. 
Among the most important we can mention Hibernate, Spring, Struts, and other more recent as Vaadin, Spring Roo, Grails ..., thanks to them the mechanical work is reduced to a minimum. 
However, none of these automates a common feature, present in all J2EE applications, the *mapping*. 
The mapping is a mechanical operation that almost 100%, in medium to large applications, including development, testing and bug fixing, reaches a weight is certainly not negligible. 
As the rule may seem elementary, enclose in a single framework a potentially unlimited number of combinations, mapping recursive addition of logic and other features, makes its implementation very complex and questionable compromises, such as poor performance, covering a limited features, etc... . 

JMapper aims not only coverage requirements but also to make it as easy as possible to use, all with performance equivalent or superior to the static mapping. 
  
JMapper specifically allows: 
 *- to perform complex mapping (Collection, Map, Array, inner classes, etc...) 
   *- to manage implicit and explicit relationships of various types: 
   *- one to one 
   *- one to many 
   *- many to one 
 *- to perform recursive mapping (mapped objects into other objects) 
 *- to configure the mapping using the annotation and / or xml
 *- to write quick and simple xml configuration file through a series of utility methods

= Preface =

Before describing the features of the framework is good to do a little introduction: the *Destination* is the instance that captures the data, the *Source* is the instance that contains the data, the goal is to get the Destination starting from the Source.
The configurations are associated with the instance variables and may be present in the Destination and Source, then we will call *target field* the  recipient field and *mapped field* the configured field.
As a prerequisite classes used for mapping must comply with the Javabean conventions http://en.wikipedia.org/wiki/JavaBean.
below shows the classes that will be used in the following examples:
{{{
class Destination{                      class Source{

    private String id;                      private String id;
    private String destinationField;        private String sourceField;
    private String other;                   private String other;

    // getter and setter...                 // getter and setter...
}                                       }
}}}
As mentioned in the introduction, JMapper allows you to configure the mapping using both annotations and XML. In the next chapter we will learn to configure classes with annotation and especially with {{{@JMap}}}.

*IMPORTANT!* _the XML configuration has greater visibility of the equivalent annotation_

= @JMap =

The annotation used to configure the single field is {{{@JMap}}}, it has several parameters, including: value.
Value is the default parameter of the annotation and therefore it is not necessary to explain it if used individually.
{{{
class Destination{                      
    
    @JMap 
    private String id;                      
    @JMap("sourceField") 
    private String destinationField;       
    private String other;                  

    // getter and setter...                
}                                     
}}}
Only the configured fields will be considered in the mapping.
Without value (eg id), it indicates that the names of the target field and the mapped field are equal. If the names are different, you must define the value (eg sourceField).

Once set up, we go immediately to a practical example:
{{{
Source source = new Source("id", "sourceField", "other");

JMapper <Destination, Souce> jmapper = new JMapper <Destination, Source>(Destination.class, Source.class);

Destination destination = jmapper.getDestination(source);

System.out.println(destination);
}}}
The class will be using is JMapper, takes as input two classes: the first from the left, belonging to the Destination and the second to Source, then just invoke the method getDestination passing an instance of Source to create an instance of Destination.
The output below shows the fields of the bean destination.
{{{
Destination [id=id, destinationField=source field, other=null]
}}}
The annotations, as mentioned previously, can be used in both classes, the result that is obtained is the same.

= JMapper constructors =

If both classes are configured, the framework will consider the configuration of the Destination Class. If you want to define which configuration to be analyzed, simply pass to the constructor the ChooseConfig enumeration.
{{{
new JMapper <Destination, Source>(Destination.class, Source.class, ChooseConfig.SOURCE);
}}}
||{{{ChooseConfig.SOURCE}}}||it evaluates the configuration of Source||
||{{{ChooseConfig.DESTINATION}}}||it evaluates the configuration of Destination||

= Implicit relations = 

Mapping a class with another in this way is simple and intuitive, also observing the previous configurations, show an important feature: they are not declared classes, allowing various features such as one to many and many-to-one implicit relationships.
These features allow to greatly reduce the amount of configurations in case you want to map an object with many others.

== Many to One ==

The Many to One relationship is obtained when Destination is configured, giving the possibility to different Source classes, to instantiate it.

The following example will clarify any doubt:
{{{
                                        class Source1{
    
                                            private String id;
                                            private String sourceField;
                                            private String other;
                     
                                            // getter and setter...  
                                        }    
 
class Destination{                      class Source2{
    @JMap
    private String id;                      private String id;
    @Jmap("sourceField")                    private String sourceField;
    private String destinationField;        private String other;
    private String other;                   
                                            // getter and setter...  
    // getter and setter...             }    
}   

                                        class Source3{
     
                                            private String id;
                                            private String sourceField;
                                            private String other;
                     
                                            // getter and setter...  
                                        }                                
}}}
Sample code:
{{{
Source1 source1 = new Source1("id1", "sourceField1", "other1");
JMapper<Destination, Source1> jmapper1 = new JMapper<Destination, Source1>(Destination.class, Source1.class);
Destination destination = jmapper1.getDestination(source1);

Source2 source2 = new Source2("id2", "sourceField2", "other2");
JMapper<Destination, Source2> jmapper2 = new JMapper<Destination, Source2>(Destination.class, Source2.class);
Destination destination = jmapper2.getDestination(source2);

Source3 source3 = new Source3("id3", "sourceField3", "other3");
JMapper<Destination, Source3> jmapper3 = new JMapper<Destination, Source3>(Destination.class, Source3.class);
Destination destination = jmapper3.getDestination(source3);
}}}
In this way, with a single configuration, you can interface a Destination class with several Source classes.

== One to Many ==

The One to Many relationship is obtained when Source is configured, giving the possibility to instantiate different Destination classes.

For example:
{{{
class Destination1{                      
                                            
    private String id;                     
    private String destinationField;       
    private String other;                   
                                                             
    // getter and setter...                                        
}                                            
                                           
class Destination2{                     class Source{
                                            @JMap
    private String id;                      private String id;
    private String destinationField;        @JMap("destinationField")
    private String other;                   private String sourceField;
                                            private String other;                   
    // getter and setter...                                        
}                                           // getter and setter...  
                                        }    
class Destination3{                      
                                         
    private String id;                  
    private String destinationField;    
    private String other;               
                                                       
    // getter and setter...                                        
}                                                                  
}}}
Sample code:
{{{
Source source = new Source("id", "sourceField", "other");
JMapper<Destination1, Source> jmapper1 = new JMapper<Destination1, Source>(Destination.class, Source.class);
Destination1 destination1 = jmapper1.getDestination(source);

JMapper<Destination2, Source> jmapper2 = new JMapper<Destination2, Source>(Destination.class, Source.class);
Destination2 destination2 = jmapper2.getDestination(source);

JMapper<Destination3, Source> jmapper3 = new JMapper<Destination3, Source>(Destination3.class, Source.class);
Destination3 destination3 = jmapper3.getDestination(source);
}}}
then, as in the many to one, with a single configuration, you can interface a Source class with several Destination classes.

= @JMap variables =

The cases just described are common but not fully satisfy the need.
For this reason, the annotation @JMap has two other parameters, and are *attributes* and *classes* both vectors.

attributes contains the identifiers of the target fields, classes their classes.

In summary, the parameters that the annotation makes available are three:
value, attributes and classes.
In the next chapters we will see what combinations of these three parameters are allowed and their usefulness.

== Value ==

Value is the default parameter that you may omit to write, if used alone.
{{{
@JMap("targetFieldName") or @JMap(value = "targetFieldName")
}}}

== Attributes ==

Can associate the mapped field to different target field.
{{{
@JMap(attributes = {"field1", "field2", "field3"})
}}}
This configuration may lead to undesirable results in the case there are multiple matches between the identifiers declared in attributes and the fields of the target class, in this case JMapper considers valid the first field that respects the correspondence. This use is recommended only if you are certain of the uniqueness of the identifiers defined.

== Classes ==

If the identifier of the target field is identical to that of the mapped field, and you want to limit the association to a defined set of classes, just use classes.
{{{
@JMap(classes = {Source1.class, Source2.class, Source3.class})
}}}

== Value and Classes ==

This combination allows you to limit the association between the mapped field and the target field to a defined set of classes.
{{{
@JMap(value = "destinationField", classes = {Destination.class})
}}}

== Attributes and Classes ==

To clarify the association between the mapped field and other fields belonging to different classes, you can simply make a joint use of attributes and classes.
{{{
@JMap(attributes = {"field1", "field2", "field3"}
         classes = {Source1.class, Source2.class, Source3.class})
}}}
In this specific example JMapper recognizes the association that exists between the mapped field with the field "field1" of the Source class, with the field "field2" of the Source2 class and with the field "field3" of the Source3 class.

The equality of the mapped field and the target field can be specified with an empty string "". For example:
{{{
@JMap(attributes = {"field1", "", "field3"}
         classes = {Source1.class, Source2.class, Source3.class})
}}}

= Explicit Relations = 

In this first part we have seen how JMapper will define relations one-to-many and many-to-one with a single configuration, this approach is useful when you are not aware of classes that may use them, but this way the developer is bound to instantiate whenever JMapper passing in input both classes.

To overcome this, the framework exposes the RelationalJMapper class.
To take advantage of this, you must define, for each mapped field, the target classes of the mapping, as shown below.
{{{
class AnnotatedClass{                      
    
    @JMap(attributes = {"field1Class1", "field1Class2", "field1Class3"}
          classes    = {Class1.class, Class2.class, Class3.class})
    private String field1;                      
    @JMap(attributes = {"field2Class1", "field2Class2", "field2Class3"}
          classes    = {Class1.class, Class2.class, Class3.class})
    private String field2;       
    @JMap(attributes = {"field3Class1", "field3Class2", "field3Class3"}
          classes    = {Class1.class, Class2.class, Class3.class})
    private String field3;                  

    // getter and setter...                
}                                     
}}}
RelationalJMapper takes as input only the configured class:
{{{
RelationalJMapper<AnnotatedClass> rm = new RelationalJMapper<AnnotatedClass>(AnnotatedClass.class);
}}}

== Many to One ==
== One to Many ==

<g:plusone size="medium"></g:plusone>