#summary description of the explicit conversions.

= Explicit conversion =

In this section the conversion is synthesized, each argument is detailed in the following chapters.<br>
Explicit conversion allows you to define your own control logic and / or processing data belonging to the source fields and assign them to the destination fields.<br>
You can define conversions through the use of methods and you can do it in java, using the annotation *@JMapConversion* and in xml format using the node *<**conversion**>*.

*IMPORTANT!* _the XML conversion has greater visibility of the equivalent in java and if no xml conversion was found, will be done a search by annotated conversion_

Conversions can be written in the Destination or Source, regardless the configuration's location, follows an example of conversion in annotation:
{{{
class Destination{                      class Source{
    @JMap
    private String id;                      private String id;
    @JMap("sourceField")
    private String destinationField;        private String sourceField;
    private String other;                   private String other;

                                            @JMapConversion
					    public String conversion(String str){
						return str;
					    }

   // getters and setters...                // getters and setters...
}                                       }
}}}
And an example in XML:
{{{
<jmapper>
  <class name="com.application.Destination">
    <attribute name="id">
      <value name="id"/>
    </attribute>
    <attribute name="destinationField">
      <value name="sourceField"/>
    </attribute>
  </class>
  <class name="com.application.Source">
    <conversion name="conversion">
		return str;
    </conversion>
  </class>
</jmapper>
}}}
You can also do a combination of the two previous examples: configuration with annotations and conversions in xml format or vice versa.<br>
conversion between the two fields is applied only when there is a relationship between them, expressed with annotations or XML, follows an example of *not applied* conversion:
{{{
class Destination{                  class Source{
    @JMap
    private String id;                  private String id;
    @JMap("sourceField")
    private String destinationField;    private String sourceField;
    private String other;               private String other;

                                        @JMapConversion(from={"id"}, to={"other"})
				        public String conversion(String str){
					   return str;
					}
    // getters and setters... 	        // getters and setters...
}                                   }
}}}
Assuming to initialize the JMapper class in the following way:
{{{
JMapper jmapper = new JMapper(Destination.class, Source.class);
}}}
relations expressed:
 * Source.id -> Destination.id
 * Source.sourceField -> Destination.destinationField

The conversion instead is defined for the relation:
 * Source.id -> Destination.other

So in this case the conversion will never be applied, the same happens also for the configuration in XML format.


The conversion method may have *one or two parameters*, depends on the logic that must be applied. A single input parameter indicates the source field, two parameters indicate the destination field and source field, this case comes in handy when you want to act on a destination field already defined.

java example:
{{{
@JMapConversion(from={"sourceField"}, to={"destinationField"})
public String conversion(String destinationField, String sourceField){
   return destinationField +" "+sourceField+" converted";
}
}}}
XML example:
{{{
<jmapper>
  <class name="com.application.Source">
    <conversion name="conversion" from="sourceField" to="destinationField">
	return ${destination}+" "+${source}+" converted";
    </conversion>
  </class>
</jmapper>
}}}
*IMPORTANT!* _The conversion, once satisfied the relationship, replaces the basis mapping of the framework_

The generated code is surrounded by a Try-Catch inserted with the aim of managing all the errors generated at runtime, such as !NullPointerException.

The conversions can be of two types: *static* and *dynamic*.
the method is static when it is used in all the defined relationships, is dynamic when the method's body change according the relationship that must be satisfied.
 
== Annotation's general instructions ==

The annotation that allows us to perform explicit conversion is the *@JMapConversion*.<br>
JMapConversion has three parameters: from, to and type.


||Field||Description||default value||
||String[] from||names of the source fields||ALL||
||String[] to||names of the destination fields||ALL||
||Type type||conversion type||STATIC||
||Boolean avoidSet (since *1.3.1*)||avoid set method usage||false||

The parameters from and to indicate which fields will be part of the conversion.
The *from* indicates the source, the *to* indicates the recipient, the default value for each is ALL.
ALL indicates that the conversion is to be applied to all related fields.
The *Type* is an enumeration of @JMapConversion that allows you to define the conversion modes and has only two values: STATIC and DYNAMIC, the default value of type is STATIC. *avoidSet* parameter set to true avoids the call to the set method.
Conversion modes are detailed in the following paragraphs.

== XML's general instructions ==

In the xml definition the conversion is defined using the *<**conversion**>* node, whose attributes are: name, from, to and type.


||Attribute||Description||default value||
||name||method name||undefined||
||from||names of the source fields (separated by commas:"field","field2")||ALL||
||to||names of the destination fields(separated by commas:"field","field2")||ALL||
||type||conversion type||STATIC||
||avoidSet (since *1.3.1*)||avoid set method usage||false||

The *name* attribute permits to define a name to the current conversion method, this attribute is *mandatory*.

*IMPORTANT!* _make sure the name is unique for proper operation._

The parameters from and to indicate which fields will be part of the conversion, the *from* indicates the source, the *to* indicates the recipient, the default value for each is ALL, ALL indicates that the conversion is to be applied to all related fields.
the *Type* is an attribute that allows you to define the conversion modes, and has only two values: STATIC and DYNAMIC, the default value of type is STATIC.
Conversion modes are detailed in the following paragraphs. *avoidSet* attribute set to true avoids the call to the set method.

*IMPORTANT!* _The code must be written according the [http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/tutorial/tutorial2.html#limit javassist specifications]._

== Static conversion ==

A conversion is called static when its body does not change with the defined relations.
Suppose we have two classes: Destination and Source, both with 3 fields of type String: d1, d2 and d3 for Destination and s1, s2, and s3 for Source and that you have configured s1 with d1, d2 with s2 and d3 with s3.
We want to define a conversion to be applied to all relationships, then the method will be defined (eg in annotation):
{{{
// you can obtain the same result writing @JMapConversion without parameters
@JMapConversion(from={"s1,s2,s3"}, to={"d1,d2,d3"}, type=Type.STATIC)
public String conversion(String source){
   return source + " converted";
}
}}}
Assuming that the method is defined in the Destination, the mapping generated at runtime will be as follows:
{{{
destination.setD1(destination.conversion(source.getS1()));
destination.setD2(destination.conversion(source.getS2()));
destination.setD3(destination.conversion(source.getS3()));
}}}
This conversion is the most common and also the most useful, allows to pool a manipulation that can affect more data.
In case there are any static methods with the same name, will be considered only the first one that meets the requirements.
 
===	In annotation ===

Consists in the definition of the conversion method using the following conventions:
 * the input field to the method must be the same type of the source fields 
 * the output field to the method must be the same type of destination fields

Example:
{{{
@JMapConversion(from={"anInteger"}, to={"aString"}, type=Type.STATIC)
public String conversion(Integer anInteger){
   return anInteger.toString();
}
}}}
Assuming that the method is defined in the Destination, JMapper generate the following mapping:
{{{
destination.setAString(destination.conversion(source.getAnInteger()));
}}}
If you want act even on the present value of the destination field, just add an input parameter, keeping in mind that the first field on the left is the destination and the second is the source:
{{{
@JMapConversion(from={"anInteger"}, to={"aString"}, type=Type.STATIC)
public String conversion(String aString, Integer anInteger){
   if(aString == null) aString = "initialized";
   return aString + anInteger;
}
}}}
The generated mapping will be as follows:
{{{
destination.setAString(destination.conversion(destination.getAString(),source.getAnInteger()));
}}}
 
=== In XML ===

Consists in the definition of the conversion node, whose value is the body of the method to create.<br>To refer to the source field and destination field you must use the following placeholders:
 * ${source} to refer to the source field
 * ${destination} to refer to the destination field

Example:
{{{
<conversion name="conversion" from="anInteger" to="aString" type="STATIC">
   return ${source}.toString();
</conversion>
}}}
Method created at runtime:
{{{
public String conversion(Integer source){
   return source.toString();
}
}}}
Mapping generated:
{{{
destination.setAString(conversion(source.getAnInteger()));
}}}
If you want to act even on the destination, just use the placeholder: ${destination}.
{{{
<conversion name="conversion" from="sourceField" to="destinationField">
   return ${destination}+" "+${source}+" converted";
</conversion>
}}}
Method created at runtime:
{{{
public String conversion(String destination, Integer source){
   return destination +" "+ source +" converted";
}
}}}
Mapping generated:
{{{
destination.setAString(conversion(destination.getAString(),source.getAnInteger()));
}}}
 
== Dynamic conversion ==

For dynamic conversion we means a method whose body is adapted to every relationship. 
The conversion method defined, both in java that in xml, is always one, but at runtime will be created a number of conversions equal to the number of relations.
The dynamic conversion allows to pool the basic logic varying only some values.<br>The placeholders that can be used both in java that in xml are as follows:

||Placeholder||Description||
||${source}||source reference||
||${destination}||destination reference||
||${source.type}||source type||
||${destination.type}||destination type||
||${source.name}||source name||
||${destination.name}||destination name||

annotation example:
{{{
@JMapConversion(from={"s1,s2,s3"}, to={"d1,d2,d3"}, type=Type.DYNAMIC)
public static String conversion(){
   return "return \"${destination.name} ${source.name}\";";
}
}}}
Method created at runtime:
{{{
public String FROMs1TOd1(){
   return "d1 s1";
}

public String FROMs2TOd2(){
   return "d2 s2";
}

public String FROMs3TOd3(){
   return "d3 s3";
}
}}}
As you can see, the methods do not take input data because there is no reference to variables using the placeholder ${source} and ${destination}.
JMapper generate the following mapping:
{{{
destination.setD1(fromS1toD1());
destination.setD2(fromS2toD2());
destination.setD3(fromS3toD3());
}}}
 
=== In annotation ===

Consists in the definition of the conversion method using the following conventions:
 * the method must be: public static
 * should not receive input parameters
 * must return a string containing the dynamic mapping

Example:
{{{
@JMapConversion(from={"anInteger"}, to={"aString"}, type=Type.DYNAMIC)
Public static String conversion(){
 return "${destination.type} result = ${source} == 2?\"${source.name}\":\"${destination.name}\";"
     +  "return result + ${destination};";
}
}}}
Method created at runtime:
{{{
public String FROManIntegerTOaString(String destination,Integer source){
   String result = source == 2? "anInteger":"aString";
   return result + destination;
}
}}}
JMapper generate the following mapping:
{{{
dest.setAString(fromAnIntegertoAString(dest.getAString(),source.getAnInteger()));
}}}

=== In XML ===

The placeholders can also be used in xml, the above example is repeated in xml format:
{{{
<conversion name="conversion" from="anInteger" to="aString" type="DYNAMIC">
   ${destination.type} result = ${source} == 2?"${source.name}":"${destination.name}";
   return result + ${destination};
</conversion>
}}}
Method created at runtime:
{{{
public String FROManIntegerTOaString(String destination,Integer source){
   String result = source == 2? "anInteger":"aString";
   return result + destination;
}
}}}
Mapping generated:
{{{
dest.setAString(fromAnIntegertoAString(dest.getAString(),source.getAnInteger()));
}}}