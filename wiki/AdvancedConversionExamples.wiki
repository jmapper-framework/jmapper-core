#summary advanced explicit conversion examples.
 
= Explicit conversion =

The dynamic conversion opens interesting scenarios.
Allows you to going in introspection avoiding the use of Reflection, an advantage not only in performance but also in code readability. 
Furthermore, the possibility to outsource the xml, permits to make changes without touch the code, thus greatly increasing the potential of the framework.

== 1° Scenario ==
This example shows the use of static conversions.
We want transform Strings to Dates.
{{{
class Dates {                 class Strings{

   @JMap Date startDate;         String startDate;
   @JMap Date endDate;           String endDate; 

   // getter and setter..        // getter and setter..
}                             }
}}}
XML configuration:
{{{
<jmapper>
  <class name="it.jmapper.bean.Strings">
    <!-- in this case we use default values -->
    <conversion name="toDate">
    	return new java.text.SimpleDateFormat("dd/MM/yyyy").parse(${source});
    </conversion>
  </class>
</jmapper>
}}}

_In this example we use annotated configurations and conversion in xml format._
<br>Method created at runtime:
{{{
public Date toDate(String source){
   return new java.text.SimpleDateFormat("dd/MM/yyyy").parse(source);
}
}}}
mapping generated:
{{{
destination.setStartDate(toDate(source.getStartDate()));
destination.setEndDate(toDate(source.getEndDate()));
}}}
example code:
{{{
JMapper<Dates, Strings> mapper = new JMapper<Dates, Strings>(Dates.class, Strings.class);
Dates destination = mapper.getDestination(new Strings("01/01/2012", "01/01/2013"));
System.out.println(destination);
}}}
output:
{{{
Dates [startDate=Tue Jan 01 00:00:00 CET 2013, endDate=Wed Jan 01 00:00:00 CET 2014]
}}}
== 2° Scenario ==

We have a properties file that we want to load in a bean.
properties file:
{{{
author = Alessandro Vurro
framework = JMapper
version = 1.1.0
label = dynamic conversion test
}}}
java beans:
{{{
class Destination{             class Source{

  @JMap("properties")
  private String author;         private Properties properties;
  @JMap("properties")
  private String framework;      @JMapConversion(from={"properties"}, type=Type.DYNAMIC)
  @JMap("properties")	         public static String conversion(){
  private String version;           return "return (String) ${source}.get(\"${destination.name}\");"; 
  @JMap("properties")            } 
  private String label;        

  // getter and setter...        // getter and setter...
       				          					     
}			       }
}}}
_@JMap allows you to configure a field with only another and not simultaneously with more fields.<br>For this reason we have configured the  Destination fields in direction to the Source field._

_For this purpose will be introduced the @JMultiMap with the 1.2.0 release._

Methods created at runtime:
{{{
public String fromPropertiestoAuthor(Properties source){
   return source.get("author");
}

public String fromPropertiestoFramework(Properties source){
   return source.get("framework");
}

public String fromPropertiestoVersion(Properties source){
   return source.get("version");
}

public String fromPropertiestoAuthor(Properties source){
   return source.get("label");
}
}}}
mapping generated:
{{{
destination.setAuthor(fromPropertiestoAuthor(source.getProperties()));
destination.setFramework(fromPropertiestoFramework(source.getProperties()));
destination.setVersion(fromPropertiestoVersion(source.getProperties()));
destination.setLabel(fromPropertiestoLabel(source.getProperties()));
}}}
example code:
{{{
JMapper<Destination,Source> mapper = new JMapper<Destination,Source>(Destination.class, Source.class);
Destination destination = mapper.getDestination(new Source(properties));
System.out.println(destination);
}}}
output:
{{{
Destination:
 author = Alessandro Vurro
 framework = JMapper
 version = 1.1.0
 label = dynamic conversion test
}}}
In the case of addition or removal of properties from the file, just add or remove the field from Destination class.

== 3° Scenario ==

We have a !HashMap that has the pair <"name field", value field> and a bean with different fields, we want to do the following:
 * load bean from !HashMap
 * load !HashMap from bean

The classes are:
{{{
class Destination{             class Source{
   
    private String  id;            private HashMap<String, Object> map;
    private Integer quantity;    
    private Date    purchase;   
                                  
    // getter and setter...        // getter and setter...
       				          					     
}			       }   
}}}
XML configuration:
{{{
<jmapper>
  <class name="com.application.Destination">
    <attribute name="id">
      <value name="map"/>
    </attribute>
    <attribute name="quantity">
      <value name="map"/>
    </attribute>
    <attribute name="purchase">
      <value name="map"/>
    </attribute>
    <conversion name="fromMapToAll" from="map" type="DYNAMIC">
	    return (${destination.type}) ${source}.get("${destination.name}");
    </conversion>
    <conversion name="fromAllToMap" to="map" type="DYNAMIC">
	    ${destination}.put("${source.name}",${source});
            return ${destination};
    </conversion>
  </class>
</jmapper>
}}}
Methods generated at runtime:
{{{
public String fromMaptoId(HashMap source){
   return (String) source.get("id");
}

public Integer fromMaptoQuantity(HashMap source){
   return (Integer) source.get("quantity");
}

public Date fromMaptoPurchase(HashMap source){
   return (Date) source.get("purchase");
}

public String fromPropertiestoAuthor(Properties source){
   return source.get("label");
}

public HashMap fromIdtoMap(HashMap destination, String source){
   destination.put("id",source);
   return destination;
}

public HashMap fromQuantitytoMap(HashMap destination, Integer source){
   destination.put("quantity",source);
   return destination;
}
public HashMap fromPurchasetoMap(HashMap destination, Date source){
   destination.put("purchase",source);
   return destination;
}
}}}
So in case we want to fill the bean starting from !HashMap the mapping used will be:
{{{
destination.setId(fromMaptoId(source.getMap()));
destination.setQuantity(fromMaptoQuantity(source.getMap()));
destination.setPurchase(fromMaptoPurchase(source.getMap()));
}}}
Instead, the mapping used to populate the !HashMap from bean:
{{{
destination.setMap(fromIdtoMap(destination.getMap(),source.getId()));
destination.setMap(fromQuantitytoMap(destination.getMap(),source.getQuantity()));
destination.setMap(fromPurchasetoMap(destination.getMap(),source.getPurchase()));
}}}
example code:
{{{
HashMap<String, Object> map = new HashMap<String, Object>();
map.put("id", "JMapper Framework v.1.1.0");
map.put("quantity", 10);
map.put("purchase", new Date());

RelationalJMapper<Destination> mapper;
mapper = new RelationalJMapper<Destination>(Destination.class,"xml/dynamicConversion.xml");

Source source = new Source(map);
Destination manyToOne = mapper.manyToOne(source);
System.out.println(manyToOne);

Source empty = new Source(new HashMap<String, Object>());
Source oneToMany = mapper.oneToMany(empty,manyToOne);
System.out.println(oneToMany);	
}}}
output:
{{{
Destination:
 id = JMapper Framework v.1.1.0
 quantity = 10
 purchase = Tue Dec 11 15:41:06 CET 2012

Source:
 map = {purchase=Tue Dec 11 15:41:06 CET 2012, quantity=10, id=JMapper Framework v.1.1.0}
}}}
In this example we use RelationalJMapper, as you can see in the oneToMany example we pass as input an empty destination instance (Source class in this case become a destination), because the conversion method uses a reference to destination.
== Overall ==

Despite the potential of dynamic conversion are so high, the performance  isn't affected, since the code continues to be generated at runtime and therefore equivalent to the static code, also increasing advantages such as:
 * reducing the amount of code ->  increase the readability
 * development simplified -> easier maintenance