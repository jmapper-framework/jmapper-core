#summary some usage examples of JMapper.

= Advanced examples =

We will see now some very interesting examples of use, which makes the code more concise and elegant.

== Layered application ==

A classic example is a web application that consists of three layers: facade, business and data access.
Each layer has two bean, one of input and one of output.
<table width = "100%"><tr><td align="center">
{{{                                                                                                       
             ____________       ____________       ____________
      PivotI |          | BoI   |          | DtoI  |          |
      ------>|  Facade  |------>| Business |------>|  Data    |
             |          |       |          |       |  Access  |
      PivotO |  Layer   | BoO   | Layer    | DtoO  |  Layer   |
      <------|          |<------|          |<------|          |
             |__________|       |__________|       |__________|
}}}
</td></tr></table>
In the architecture of this type, for each service you need to implement four mapping: {{{PivotI -> BoI -> DtoI}}} and {{{DtoO -> BoO -> PivotO}}}.

With Jmapper you need to configure only the two business objects, with the surrounding objects.
<table width = "100%"><tr><td width="50%">
{{{
   class PivotI{
       String pivotIfield;
   }

   class BoI{              
       @JMap(attributes={"pivotIfield", "dtoIfield"}
             classes   ={PivotI.class,  DtoI.class}) 
       Integer boIfield; 
   }

   class DtoI{
       Integer dtoIfield;
   }
}}}
</td><td width="50%">
{{{
   class PivotO{
       String pivotOfield;
   }

   class BoO{              
       @JMap(attributes={"pivotOfield", "dtoOfield"}
             classes   ={PivotO.class,  DtoO.class}) 
       Integer boOfield; 
   }

   class DtoO{
       Integer dtoOfield;
   }
}}}
</td></tr></table>
below the sample code:
{{{
   class ExampleFacade{
       
       RelationalJMapper<BoI> rmI;
       RelationalJMapper<BoO> rmO;
       ExampleBusiness exampleBusiness;

       public PivotO executes(PivotI pivotI){
           
           // mapping
           BoI boI = rmI.manyToOne(pivotI);

           // logic
           BoO boO = exampleBusiness.executes(boI);

           // mapping
           PivotO pivotO = rmO.setDestinationClass(PivotO.class).oneToMany(boO);
           
           return pivotO;
       }      
   }
   
   class ExampleBusiness{

       RelationalJMapper<BoI> rmI;
       RelationalJMapper<BoO> rmO;
       ExampleDAO exampleDao;

       public BoO executes(BoI boI){
           
           // mapping
           DtoI dtoI = rmI.setDestinationClass(DtoI.class).oneToMany(boI);

           // logic
           DtoO dtoO = exampleDao.executes(dtoI);
           
           // mapping
           BoO boO = rmO.manyToOne(dtoO);

           return boO;
       }      
   }

   class ExampleDao{

       public DtoO executes(DtoI dtoI){
           // some operations
           return dtoO;
       }

   }
}}}
*Two Configurations and two instances of RelationalJMapper is all you need*.

== common logic for different objects ==

You may have the need to apply a common logic in most parts of the web application, using different objects as input.
Standard solutions can be:
 * use *instanceof* to identify class type
 * pass, as input to the method, the values â€‹to handle

Any solution that you can design, you will always have the need to change the code for every little request. With JMapper becomes:

Input objects:
<table width = "100%"><tr><td width = "33%">
{{{
class Service1I{

   List<String> customersIds;

}
}}}
</td><td width = "33%">
{{{
class Service2I{

   Set<Integer> companyIds;

}
}}}
</td><td width = "33%">
{{{
class Service3I{

   TreeSet<String> supplierIds;

}
}}}
</td></tr></table>
As you can see, the fields have different structures, JMapper handles all implicitly.
<table  width ="100%"><tr><td width="33%">
{{{


class CommonLogicI{

   List<Integer> ids;

}













}}}
</td><td width="66%">
{{{
Xml configuration:
<jmapper>
  <class name='com.myapplication.CommonLogicI'>
    <attribute name='ids'>
      <attributes>
        <attribute name='customersIds' />
        <attribute name='companyIds' />
        <attribute name='supplierIds' />
      </attributes>
      <classes>
        <class name='com.myapplication.Service1I' />
        <class name='com.myapplication.Service2I' />
        <class name='com.myapplication.Service3I' />
      </classes>
    </attribute>
  </class>
</jmapper>
}}}
</td></tr></table>
service implementations:
<table width = "100%"><tr><td width = "33%">
{{{
class Service1{

   CommonLogic cl;
    
   public void executes(Service1I service1I){
      cl.idControl(service1I);
   }
}
}}}
</td><td width = "33%">
{{{
class Service2{

   CommonLogic cl;
    
   public void executes(Service2I service2I){
      cl.idControl(service2I);
   }
}
}}}
</td><td width = "33%">
{{{
class Service3{

   CommonLogic cl;
    
   public void executes(Service3I service3I){
      cl.idControl(service3I);
   }
}
}}}
</td></tr></table>
!CommonLogic implementation:
<table width ="100%"><tr><td width ="33%">
{{{
class CommonLogic{
    
   RelationalJMapper<CommonLogicI> rm;

   public void idControl(Object source){

      CommonLogicI clI=rm.manyToOne(source);
      someOperations(clI);

    }
}
}}}
</td><td width="66%" align ="center">
The conversions between different structures are performed implicitly, including the conversion of their elements.

*Elegance, high performance and robustness all in one project*

                        <h2><b>JMapper</b></h2>
</td></tr></table>