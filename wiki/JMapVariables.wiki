#summary This page describes the JMap annotation in its entirety
= @JMap =

The cases just described are common but not fully satisfy the need.
For this reason, the annotation @JMap has two other parameters, and they are *attributes* and *classes* both vectors.

attributes contains the identifiers of the target fields, classes their classes.

In summary, the parameters that the annotation makes available are three:
value, attributes and classes.
In the next chapters we will see what combinations of these three parameters are allowed and their usefulness.

*IMPORTANT!* _With {{{@JMap}}} annotation or {{{<attribute>}}} node, you can only define a 1 to 1 relation between fields._ 

== Value ==

Value is the default parameter that you may omit to write, if used alone.
{{{
@JMap("targetFieldName") or @JMap(value = "targetFieldName")
}}}
Value is the name of the target field.

== Attributes ==

With attributes you can associate more target fields to a mapped field.
{{{
@JMap(attributes = {"field1", "field2", "field3"})
}}}
This configuration may lead to undesirable results in the case there are multiple matches between the identifiers declared in attributes and the fields of the target class, in this case JMapper considers valid the first field that respects the correspondence. This use is recommended only if you are certain of the uniqueness of the identifiers defined.<br>
For example, we have the following classes:
{{{
class Destination {          class Source {

   String dField3;              @JMap(attributes={"dField1","dField2","dField3"})
   String dField2;              String sField1; 
   String dField1;

   //getter and setter..        //getter and setter..
}                            }
}}}
Code:
{{{
Source source = new Source("sField1");

JMapper mapper = new JMapper(Destination.class, Source.class);

Destination destination = mapper.getDestination(source);

System.out.println(destination);
}}}
Output:
{{{
Destination[dField3=null, dField2=null, dField1="sField1"]
}}}
== Classes ==

Classes is used when you want to limit the association to a defined set of classes, without value and attributes, you indicates to JMapper that the identifier of target field is the same of mapped field.
{{{
@JMap(classes = {Source1.class, Source2.class, Source3.class})
}}}
For example, we have the following classes:
{{{
   class Target4 {        class Source{

                                   @JMap(classes={Target1.class, Target2.class, Target3.class})
       String field;               String field;

       // getter and setter..      // getter and setter.. 
   }                           }
}}}
Code:
{{{
new JMapper<Target4, Source>(Target4.class, Source.class);
}}}
Output:
{{{
JMapper AbsentRelationshipException: there isn't relationship between Target4 Class and Source Class
}}}
== Value and Classes ==

This combination allows you to limit the association between the mapped field and the target field to a defined set of classes, declaring the target field name.
{{{
@JMap(value = "destinationField", classes = {Destination.class})
}}}

== Attributes and Classes ==

To clarify the association between the mapped field and other fields belonging to different classes, you can simply make a joint use of attributes and classes.
{{{
@JMap(attributes = {"field1", "field2", "field3"}
         classes = {Source1.class, Source2.class, Source3.class})
}}}
In this specific example JMapper recognizes the association that exists between the mapped field with the field "field1" of the Source class, with the field "field2" of the Source2 class and with the field "field3" of the Source3 class.

The equality of the mapped field and the target field can be specified with an empty string "". For example:
{{{
@JMap(attributes = {"field1", "", "field3"}
         classes = {Source1.class, Source2.class, Source3.class})
}}}